package service

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/coreos/go-oidc/v3/oidc"
	"github.com/golang-jwt/jwt/v5"
	"github.com/kr/pretty"
	"github.com/nanoteck137/authlab/config"
	"github.com/nanoteck137/authlab/database"
	"github.com/nanoteck137/authlab/tools/utils"
	"golang.org/x/oauth2"
)

// TODO(patrik): Move the generation code
const (
	letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	digits  = "0123456789"
)

func randomString(charset string, length int) (string, error) {
	b := make([]byte, length)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}

	for i := range b {
		b[i] = charset[int(b[i])%len(charset)]
	}
	return string(b), nil
}

func GenerateCode() (string, error) {
	part1, err := randomString(letters, 4)
	if err != nil {
		return "", err
	}

	part2, err := randomString(digits, 4)
	if err != nil {
		return "", err
	}

	part3, err := randomString(letters, 4)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%s-%s-%s", part1, part2, part3), nil
}

func GenerateAuthChallenge() (string, error) {
	b := make([]byte, 64)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}

	return base64.RawURLEncoding.EncodeToString(b), nil
}

var (
	ErrAuthServiceRequestAlreadyExists = errors.New("AuthService: request already exists")
	ErrAuthServiceRequestNotFound      = errors.New("AuthService: request not found")
	ErrAuthServiceRequestExpired       = errors.New("AuthService: request is expired")
	ErrAuthServiceRequestNotReady      = errors.New("AuthService: request is not ready")
	ErrAuthServiceRequestInvalid       = errors.New("AuthService: request is invalid")
)

const (
	AuthRequestExpireDuration   = 5 * time.Minute
	AuthRequestDeletionDuration = AuthRequestExpireDuration + 10*time.Minute

	AuthQuickRequestExpireDuration   = 5 * time.Minute
	AuthQuickRequestDeletionDuration = AuthQuickRequestExpireDuration + 10*time.Minute
)

// TODO(patrik): Remove?
type AuthRequestType string

const (
	AuthRequestTypeNormal    AuthRequestType = "normal"
	AuthRequestTypeQuickCode AuthRequestType = "quick-code"
)

type AuthRequestStatus string

const (
	AuthRequestStatusPending   AuthRequestStatus = "pending"
	AuthRequestStatusCompleted AuthRequestStatus = "completed"
	AuthRequestStatusExpired   AuthRequestStatus = "expired"
	AuthRequestStatusFailed    AuthRequestStatus = "failed"
)

type AuthQuickRequestStatus string

const (
	AuthQuickRequestStatusPending   AuthQuickRequestStatus = "pending"
	AuthQuickRequestStatusCompleted AuthQuickRequestStatus = "completed"
	AuthQuickRequestStatusExpired   AuthQuickRequestStatus = "expired"
	AuthQuickRequestStatusFailed    AuthQuickRequestStatus = "failed"
)

type AuthRequest struct {
	Id         string
	ProviderId string

	Type   AuthRequestType
	Status AuthRequestStatus

	OAuth2Url  string
	OAuth2Code string

	QuickCode string

	Expires time.Time
	Delete  time.Time
}

type AuthProvider struct {
	Id          string
	DisplayName string

	provider     *oidc.Provider
	oauth2Config *oauth2.Config
	verifier     *oidc.IDTokenVerifier
}

func (p *AuthProvider) init(ctx context.Context, config config.ConfigOidcProvider) error {
	var err error

	p.provider, err = oidc.NewProvider(ctx, config.IssuerUrl)
	if err != nil {
		return fmt.Errorf("failed to create OIDC provider (%s): %w", err, p.Id)
	}

	p.oauth2Config = &oauth2.Config{
		ClientID:     config.ClientId,
		ClientSecret: config.ClientSecret,
		RedirectURL:  config.RedirectUrl,
		Endpoint:     p.provider.Endpoint(),
		Scopes:       []string{oidc.ScopeOpenID, "profile", "email"},
	}

	p.verifier = p.provider.Verifier(&oidc.Config{ClientID: config.ClientId})

	return nil
}

type providerClaim struct {
	Email       string `json:"email"`
	Name        string `json:"name"`
	DisplayName string `json:"display_name"`
	Picture     string `json:"picture"`
	Sub         string `json:"sub"`
}

func (p *AuthProvider) claim(ctx context.Context, code string) (providerClaim, error) {
	oauth2Token, err := p.oauth2Config.Exchange(ctx, code)
	if err != nil {
		return providerClaim{}, err
	}

	rawIDToken, ok := oauth2Token.Extra("id_token").(string)
	if !ok {
		return providerClaim{}, errors.New("failed to login")
	}

	idToken, err := p.verifier.Verify(ctx, rawIDToken)
	if err != nil {
		return providerClaim{}, err
	}

	// {
	// 	var t map[string]any
	// 	err = idToken.Claims(&t)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	//
	// 	pretty.Println(t)
	// }

	var claims providerClaim
	err = idToken.Claims(&claims)
	if err != nil {
		return providerClaim{}, err
	}

	return claims, nil
}

// TODO(patrik): Delete this when timer is out
type AuthQuickConnectRequest struct {
	// the status of the request
	status AuthQuickRequestStatus
	// the code of this request, generated by GenerateCode
	// example "ABCD-1234-EFGH"
	code string

	// small token generated by GenerateAuthChallenge and is returned
	// to the client when initiating, then is checked when trying to
	// create the JWT token
	challenge string

	// This is set then status == completed, and is the userId of
	// the user that authorized the request
	userId string

	// the expiry date of this request
	expires time.Time
	// the date of then we can delete this request
	delete time.Time
}

type AuthService struct {
	db        *database.Database
	jwtSecret string

	initialized bool

	providers map[string]*AuthProvider

	Requests             map[string]*AuthRequest
	QuickConnectRequests map[string]*AuthQuickConnectRequest
}

func NewAuthService(db *database.Database, jwtSecret string) *AuthService {
	return &AuthService{
		db:                   db,
		jwtSecret:            jwtSecret,
		initialized:          false,
		providers:            make(map[string]*AuthProvider),
		Requests:             make(map[string]*AuthRequest),
		QuickConnectRequests: make(map[string]*AuthQuickConnectRequest),
	}
}

type RequestResult struct {
	RequestId string
	AuthUrl   string
	Expires   time.Time
}

func (a *AuthService) CreateNormalRequest(providerId string) (RequestResult, error) {
	// TODO(patrik): Add init check?

	provider, exists := a.providers[providerId]
	if !exists {
		// TODO(patrik): Better error
		return RequestResult{}, errors.New("provider not found")
	}

	id := utils.CreateId()

	t := time.Now()
	request := &AuthRequest{
		Id:         id,
		ProviderId: provider.Id,
		Type:       AuthRequestTypeNormal,
		Status:     AuthRequestStatusPending,
		Expires:    t.Add(AuthRequestExpireDuration),
		Delete:     t.Add(AuthRequestDeletionDuration),
	}

	_, exists = a.Requests[id]
	if exists {
		return RequestResult{}, ErrAuthServiceRequestAlreadyExists
	}

	authUrl := provider.oauth2Config.AuthCodeURL(request.Id)

	request.OAuth2Url = authUrl

	a.Requests[id] = request

	return RequestResult{
		RequestId: id,
		AuthUrl:   authUrl,
		Expires:   request.Expires,
	}, nil
}

type QuickConnectRequestResult struct {
	Code      string
	Challenge string
	Expires   time.Time
}

func (a *AuthService) CreateQuickConnectRequest() (QuickConnectRequestResult, error) {
	// TODO(patrik): Add init check?

	// TODO(patrik): Generate the code
	code, err := GenerateCode()
	if err != nil {
		return QuickConnectRequestResult{}, fmt.Errorf("failed to generate code: %w", err)
	}

	challenge, err := GenerateAuthChallenge()
	if err != nil {
		return QuickConnectRequestResult{}, fmt.Errorf("failed to generate challenge: %w", err)
	}

	t := time.Now()
	request := &AuthQuickConnectRequest{
		status:    AuthQuickRequestStatusPending,
		code:      code,
		challenge: challenge,
		expires:   t.Add(AuthQuickRequestExpireDuration),
		delete:    t.Add(AuthQuickRequestDeletionDuration),
	}

	_, exists := a.QuickConnectRequests[code]
	if exists {
		return QuickConnectRequestResult{}, err
	}

	a.QuickConnectRequests[code] = request

	return QuickConnectRequestResult{
		Code:    code,
		Expires: request.expires,
	}, nil
}

func (a *AuthService) CompleteQuickConnectRequest(requestCode, userId string) error {
	request, exists := a.QuickConnectRequests[requestCode]
	if !exists {
		return ErrAuthServiceRequestNotFound
	}

	if time.Now().After(request.expires) {
		request.status = AuthQuickRequestStatusExpired
		return ErrAuthServiceRequestExpired
	}

	if request.status == AuthQuickRequestStatusPending {
		request.status = AuthQuickRequestStatusCompleted
		request.userId = userId
	}

	return nil
}

func (a *AuthService) CompleteRequest(requestId, code string) error {
	request, exists := a.Requests[requestId]
	if !exists {
		return ErrAuthServiceRequestNotFound
	}

	if time.Now().After(request.Expires) {
		request.Status = AuthRequestStatusExpired
		return ErrAuthServiceRequestExpired
	}

	if request.Status == AuthRequestStatusPending {
		request.Status = AuthRequestStatusCompleted
		request.OAuth2Code = code
	}

	return nil
}

func (a *AuthService) GetAuthCode(requestId string) (*string, error) {
	request, exists := a.Requests[requestId]
	if !exists {
		return nil, ErrAuthServiceRequestNotFound
	}

	if request.Status != AuthRequestStatusCompleted {
		return nil, nil
	}

	return &request.OAuth2Code, nil
}

func (a *AuthService) CheckQuickConnectRequestStatus(code string) (AuthQuickRequestStatus, error) {
	request, exists := a.QuickConnectRequests[code]
	if !exists {
		return AuthQuickRequestStatusFailed, ErrAuthServiceRequestNotFound
	}

	now := time.Now()
	if now.After(request.expires) {
		request.status = AuthQuickRequestStatusExpired
	}

	return request.status, nil
}

func (a *AuthService) CreateAuthTokenForQuickConnect(requestCode string) (string, error) {
	request, exists := a.QuickConnectRequests[requestCode]
	if !exists {
		return "", ErrAuthServiceRequestNotFound
	}

	if request.status != AuthQuickRequestStatusCompleted {
		return "", ErrAuthServiceRequestInvalid
	}

	if request.userId == "" {
		return "", ErrAuthServiceRequestInvalid
	}

	request.status = AuthQuickRequestStatusExpired

	// TODO(patrik): Check userId?
	token, err := a.SignUserToken(request.userId)
	if err != nil {
		return "", err
	}

	return token, nil
}

func (a *AuthService) InvalidateRequest(requestId string) error {
	request, exists := a.Requests[requestId]
	if !exists {
		return ErrAuthServiceRequestNotFound
	}

	request.Status = AuthRequestStatusExpired

	return nil
}

func (a *AuthService) GetUserFromCode(ctx context.Context, providerId, code string) (string, error) {
	provider, exists := a.providers[providerId]
	if !exists {
		// TODO(patrik): Fix error
		return "", errors.New("provider not found")
	}

	oidcClaims, err := provider.claim(ctx, code)
	if err != nil {
		return "", err
	}

	pretty.Println(oidcClaims)

	getOrCreateUser := func() (string, error) {
		user, err := a.db.GetUserByEmail(ctx, oidcClaims.Email)
		if err != nil {
			if errors.Is(err, database.ErrItemNotFound) {
				displayName := oidcClaims.DisplayName
				if displayName == "" {
					displayName = oidcClaims.Name
				}

				user, err = a.db.CreateUser(ctx, database.CreateUserParams{
					Email:       oidcClaims.Email,
					DisplayName: displayName,
					Role:        "user",
				})
				if err != nil {
					return "", err
				}

				return user.Id, nil
			} else {
				return "", err
			}
		}

		return user.Id, nil
	}

	identity, err := a.db.GetUserIdentity(ctx, providerId, oidcClaims.Sub)
	if err != nil {
		if errors.Is(err, database.ErrItemNotFound) {
			userId, err := getOrCreateUser()
			if err != nil {
				return "", err
			}

			err = a.db.CreateUserIdentity(ctx, database.CreateUserIdentityParams{
				Provider:   providerId,
				ProviderId: oidcClaims.Sub,
				UserId:     userId,
			})
			if err != nil {
				return "", err
			}

			return userId, nil
		} else {
			return "", err
		}
	}

	return identity.UserId, nil
}

func (a *AuthService) SignUserToken(userId string) (string, error) {
	user, err := a.db.GetUserById(context.Background(), userId)
	if err != nil {
		return "", err
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"userId": user.Id,
		"iat":    time.Now().Unix(),
		// "exp":    time.Now().Add(1000 * time.Second).Unix(),
	})

	tokenString, err := token.SignedString(([]byte)(a.jwtSecret))
	if err != nil {
		return "", err
	}

	return tokenString, nil
}

func (a *AuthService) RemoveUnusedEntries() {
	now := time.Now()
	for k, request := range a.Requests {
		if now.After(request.Delete) {
			delete(a.Requests, k)
		}
	}

	for k, request := range a.QuickConnectRequests {
		if now.After(request.delete) {
			delete(a.Requests, k)
		}
	}
}

func (a *AuthService) RunRoutine() {
	ticker := time.NewTicker(30 * time.Minute)
	for range ticker.C {
		slog.Info("AuthService: running auth cleanup")
		a.RemoveUnusedEntries()
	}
}

func (a *AuthService) Init(ctx context.Context, config *config.Config) error {
	if a.initialized {
		return nil
	}

	for id, provider := range config.OidcProviders {
		res := &AuthProvider{
			Id:          id,
			DisplayName: provider.Name,
		}

		// TODO(patrik): Store the error on the provider and show
		// that in the frontend
		err := res.init(ctx, provider)
		if err != nil {
			return fmt.Errorf("AuthService: failed to initialize AuthProvider: %w", err)
		}

		a.providers[id] = res
	}

	go a.RunRoutine()

	a.initialized = true

	return nil
}
